/*
 * This file is part of the honeybrid project.
 *
 * Copyright (C) 2007-2009 University of Maryland (http://www.umd.edu)
 * (Written by Robin Berthier <robinb@umd.edu>, Thomas Coquelin <coquelin@umd.edu> and Julien Vehent <jvehent@umd.edu> for the University of Maryland)
 *
 * Honeybrid is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */


OVERVIEW

Thank you for your interest in honeybrid!
The goal of honeybrid is to combine low and high interaction honeypot to provide an highly scalable
honeypot framework. This goal is achieved through a redirection mechanism that can transparently
change the destination of a network session (TCP or UDP). Thus, uninteresting traffic can be handled
by a front-end of low interaction honeypots, while interesting attacks can be forwarded to a back-end
of high interaction honeypots for further analysis.

Honeybrid is a program that runs on a gateway between the farm of honeypots and the Internet.
Honeybrid has two main components:
 - a Decision Engine that analyzes incoming packets from Internet and that decide which connection should
   be redirected and when the redirection should occur,
 - a Redirection Engine that handles the network session to change dynamically and transparently the 
   destination IP.


EXAMPLE

Netfilter's functions are used to redirect traffic to honeybrid. It is important to correctly add
the queueing rules using iptables for honeybrid to receive the traffic it needs.
For example, in an architecture like the following:

                          +=================+
+----------+              |eth0            ||
| attacker | ===========> ||   HONEYBRID   ||
|(internet)|              ||   10.0.0.1:eth1|
+----------+              +=================+
                           /            \
                          /              \
                     +--------+          +---------+
                     |honeypot|          | honeyd  |
                     |10.0.0.3|          |10.0.0.2 |
                     +--------+          +---------+

The following rules will queue the traffic from the attacker to honeyd and from honeyd to the attacker, as well
as from the high interaction honeypot to honeybrid:
iptables -A FORWARD -p tcp -i eth1 -s 10.0.0.2 -j QUEUE -m comment --comment 'honeybrid: packets from honeyd (LIH)'
iptables -A FORWARD -p tcp -i eth0 -d 10.0.0.2 -j QUEUE -m comment --comment 'honeybrid: packets to honeyd (LIH)'
iptables -A FORWARD -p tcp -i eth1 -s 10.0.0.3 -j QUEUE -m comment --comment 'honeybrid: packets from honeypot (HIH)'

Don't forget to active the routing mode:
echo 1 > /proc/sys/net/ipv4/ip_forward


CONTACT

Send problems, bug reports, questions and comments to robinb@umd.edu


DOCUMENTATION

The documentation is currently maintained through the numerous comments in the configuration files (for users)
and in the code (for developers).
To concentrate all these comments into a coherent manual is in process.


DEVELOPMENT

Adding a new module -- Example with the module RANDOM:
 1. Create two files: random_mod.c and random_mod.h
 2. random_mod.h can be left empty (but the file needs to be created!
    random_mod.c must have at least the following two functions:
	- int  init_mod_random () 	[** this is optional, only if you need some initialization **]
	- void mod_random (struct mod_args args)
    random_mod.c has also to have the following includes:
	#include "tables.h"
	#include "modules.h"
	#include "netcode.h"
	#include "random_mod.h"
 3. Modify the Makefile to:
	- add random_mod.c to the target SRC
	- add random_mod.h to the target main.o
	- random_mod.o: log.h tables.h modules.h types.h
 4. Add the following function declarations in modules.h:
	int init_mod_random();		[** this is optional, only if you need some initialization **]
	void mod_random(struct mod_args args);
 5. Add the following call in the function mod_table_init() in modules.c:
	init_mod_random();		[** this is optional, only if you need some initialization **]
 6. Add the following condition in the function get_module() in modules.c:
	else if(!strncmp(modname,"random",6))
                return mod_random;

Now that you completed these 6 steps, your module is defined and hooked to
the system. The last task is to get it do something! For this you just have
to fill the function mod_random() with instructions.
The args structure given in argument of mod_random() has two main variables:
 - args.pkt is a struct_pkt where you can extract args.pkt->connection_data to have
   access to the connection structure
 - args.node has two interesting variables: 
	args.node->arg is the argument configured for this module and this
	 connection in the rules of honeybrid
	args.node->result is an integer that must be updated at the end of
	 the processing in mod_random(), either with 0 (discard) or 1 (replay)

To illustrate how everything works together, here is the content of mod_random():
 --8<------------------------------
  void mod_random(struct mod_args args)
  {
        L("mod_random():\tModule called\n", NULL, 3, args.pkt->connection_data->id);

        unsigned int value;
        unsigned int proba;
        int selector = 1;
        char *logbuf;

        /*! by defaut we discard
         */
        args.node->result = 0;

        /*! getting the value provided in argument
         */
        sscanf(args.node->arg,"%d",&value);
        if (value < selector) {
                logbuf = malloc(256);
                sprintf(logbuf, "mod_random():\tIncorrect value given in argument: %d\n", value);
                L(NULL, logbuf, 3, args.pkt->connection_data->id);
                return;
        }

        /*! deciding based on a probability of 1 out of "value":
         */
        proba = (int) (((double)value) * (rand() / (RAND_MAX + 1.0)));

        if (proba == selector) {
                args.node->result = 1;
                logbuf = malloc(256);
                sprintf(logbuf,"mod_random():\tPACKET MATCH RULE for random(%d)\n", value);
                L(NULL, logbuf, 2, args.pkt->connection_data->id);
        } else {
                args.node->result = 0;
                logbuf = malloc(256);
                sprintf(logbuf,"mod_random():\tPACKET DOES NOT MATCH RULE for random(%d)\n", value);
                L(NULL, logbuf, 2, args.pkt->connection_data->id);
        }

        return;
  }
 ----------------------------------
